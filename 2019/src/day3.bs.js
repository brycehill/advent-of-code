// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Lib$AdventOfCode19 = require("./Lib.bs.js");

function splitOnComma(param) {
  return param.split(",");
}

function splitOnNewLines(param) {
  return param.split("\n");
}

function addFst(amount, param) {
  return /* tuple */[
          param[0] + amount | 0,
          param[1]
        ];
}

function addSnd(amount, param) {
  return /* tuple */[
          param[0],
          param[1] + amount | 0
        ];
}

function measureDistance(pair1, pair2) {
  return Math.abs(pair1[0] - pair2[0] | 0) + Math.abs(pair1[1] - pair2[1] | 0) | 0;
}

var start = /* tuple */[
  0,
  0
];

var directions = Curry._1(Lib$AdventOfCode19.Lib.openFile, "input3.txt").split("\n");

var wire1Steps = Caml_array.caml_array_get(directions, 0).split(",");

var wire2Steps = Caml_array.caml_array_get(directions, 1).split(",");

function parseInstruction(instruction) {
  var direction = $$String.sub(instruction, 0, 1);
  var amount = Curry._1(Lib$AdventOfCode19.Lib.fromString, $$String.sub(instruction, 1, instruction.length - 1 | 0));
  return /* tuple */[
          direction,
          amount
        ];
}

function buildCoords(pairFn, curr, all) {
  return List.fold_left((function (acc, param) {
                var lastCoord = List.hd(acc);
                var newPair = Curry._1(pairFn, lastCoord[/* pair */0]);
                return /* :: */[
                        /* record */[
                          /* pair */newPair,
                          /* totalSteps */lastCoord[/* totalSteps */1] + 1 | 0
                        ],
                        acc
                      ];
              }), curr, all);
}

function cmp(c1, c2) {
  var match = c1[/* pair */0];
  var match$1 = c2[/* pair */0];
  var x = Caml_primitive.caml_int_compare(match[0], match$1[0]);
  if (x !== 0) {
    return x;
  } else {
    return Caml_primitive.caml_int_compare(match[1], match$1[1]);
  }
}

var CoordComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

function toSet(list) {
  return Belt_Set.keep(Belt_Set.fromArray($$Array.of_list(list), CoordComparator), (function (coord) {
                return Caml_obj.caml_notequal(coord[/* pair */0], start);
              }));
}

function stepsToCoords(steps) {
  return toSet($$Array.fold_left((function (cs, instruction) {
                    var lastStep = List.hd(cs);
                    var match = parseInstruction(instruction);
                    var all = Belt_List.make(match[1], start);
                    var newCoords;
                    switch (match[0]) {
                      case "D" :
                          newCoords = buildCoords((function (param) {
                                  return addSnd(-1, param);
                                }), /* :: */[
                                lastStep,
                                /* [] */0
                              ], all);
                          break;
                      case "L" :
                          newCoords = buildCoords((function (param) {
                                  return addFst(-1, param);
                                }), /* :: */[
                                lastStep,
                                /* [] */0
                              ], all);
                          break;
                      case "R" :
                          newCoords = buildCoords((function (param) {
                                  return addFst(1, param);
                                }), /* :: */[
                                lastStep,
                                /* [] */0
                              ], all);
                          break;
                      case "U" :
                          newCoords = buildCoords((function (param) {
                                  return addSnd(1, param);
                                }), /* :: */[
                                lastStep,
                                /* [] */0
                              ], all);
                          break;
                      default:
                        newCoords = /* [] */0;
                    }
                    return Pervasives.$at(newCoords, cs);
                  }), /* :: */[
                  /* record */[
                    /* pair */start,
                    /* totalSteps */0
                  ],
                  /* [] */0
                ], steps));
}

var set1 = stepsToCoords(wire1Steps);

var set2 = stepsToCoords(wire2Steps);

var fewestSteps = Belt_Set.reduce(Belt_Set.intersect(set1, set2), 1000000, (function (fewestSteps, coord) {
        var found1 = Belt_Set.get(set1, coord);
        var found2 = Belt_Set.get(set2, coord);
        if (found1 !== undefined && found2 !== undefined) {
          var newTotal = found2[/* totalSteps */1] + found1[/* totalSteps */1] | 0;
          var match = newTotal < fewestSteps;
          if (match) {
            return newTotal;
          } else {
            return fewestSteps;
          }
        } else {
          return fewestSteps;
        }
      }));

console.log("Fewest Steps:", fewestSteps);

var Lib = Lib$AdventOfCode19.Lib;

var $$Set = 0;

exports.Lib = Lib;
exports.$$Set = $$Set;
exports.splitOnComma = splitOnComma;
exports.splitOnNewLines = splitOnNewLines;
exports.addFst = addFst;
exports.addSnd = addSnd;
exports.measureDistance = measureDistance;
exports.start = start;
exports.directions = directions;
exports.wire1Steps = wire1Steps;
exports.wire2Steps = wire2Steps;
exports.parseInstruction = parseInstruction;
exports.buildCoords = buildCoords;
exports.CoordComparator = CoordComparator;
exports.toSet = toSet;
exports.stepsToCoords = stepsToCoords;
exports.set1 = set1;
exports.set2 = set2;
exports.fewestSteps = fewestSteps;
/* directions Not a pure module */
